import fs from 'node:fs';
import path from 'node:path';
import { promisify } from 'node:util';
import type { ActionResult, ItemStatus } from './types.js';
import { DOTFILES_ROOT, STARSHIP_DOTFILES_ROOT, MANAGED_STARSHIP_TOML_PATH, FZF_DOTFILES_ROOT, MANAGED_FZF_ZSH_PATH, MANAGED_BAT_THEMES_DIR, USER_BAT_THEMES_DIR } from '../lib/paths.js';
import { runCommand } from '../lib/exec.js';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const mkdir = promisify(fs.mkdir);

export type Palette = { name?: string } & Record<string, string>;

function palettesDir() {
  return path.join(DOTFILES_ROOT, 'theme', 'palettes');
}

function activeFilePath() {
  return path.join(DOTFILES_ROOT, 'theme', 'active.json');
}

export async function listPalettes(): Promise<string[]> {
  const dir = palettesDir();
  try {
    const items = await fs.promises.readdir(dir);
    return items.filter((f) => f.endsWith('.json')).map((f) => f.replace(/\.json$/, ''));
  } catch {
    return [];
  }
}

export async function getActivePaletteName(): Promise<string | null> {
  try {
    const content = await readFile(activeFilePath(), 'utf8');
    const data = JSON.parse(content) as { name: string };
    return data.name || null;
  } catch {
    return null;
  }
}

export async function setActivePaletteName(name: string): Promise<void> {
  await fs.promises.mkdir(path.dirname(activeFilePath()), { recursive: true });
  await writeFile(activeFilePath(), JSON.stringify({ name }, null, 2), 'utf8');
}

function hexToRgb(hex: string) {
  const cleaned = hex.replace('#', '');
  const bigint = parseInt(cleaned, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255,
  };
}

function lighten(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const adjust = (v: number) => Math.min(255, Math.round(v + 255 * amount));
  const toHex = (v: number) => v.toString(16).padStart(2, '0');
  return `#${toHex(adjust(r))}${toHex(adjust(g))}${toHex(adjust(b))}`;
}

function darken(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const adjust = (v: number) => Math.max(0, Math.round(v - 255 * amount));
  const toHex = (v: number) => v.toString(16).padStart(2, '0');
  return `#${toHex(adjust(r))}${toHex(adjust(g))}${toHex(adjust(b))}`;
}

export async function getStatusList(): Promise<ItemStatus[]> {
  const available = await listPalettes();
  const active = (await getActivePaletteName()) || (available[0] ?? null);
  return [
    { id: 'theme-palettes', label: 'Palettes available', level: available.length > 0 ? 'ok' : 'error', details: available.join(', ') || 'None' },
    { id: 'theme-active', label: 'Active palette', level: active ? 'ok' : 'warning', details: active || 'None' },
    { id: 'starship-theme', label: 'Starship theme generated', level: fs.existsSync(MANAGED_STARSHIP_TOML_PATH) ? 'ok' : 'warning', details: MANAGED_STARSHIP_TOML_PATH },
  ];
}

export async function diff(): Promise<ActionResult> {
  return { ok: true, message: 'Theme diffs are generated artifacts; edit palette.json instead.' };
}

export async function install(): Promise<ActionResult> {
  return build();
}

export async function update(): Promise<ActionResult> {
  return build();
}

export async function build(): Promise<ActionResult> {
  try {
    const available = await listPalettes();
    let active = await getActivePaletteName();
    if (!active && available.length > 0) {
      active = available[0];
      await setActivePaletteName(active);
    }
    if (!active) return { ok: false, message: 'No palettes found' } as ActionResult;

    const palettePath = path.join(palettesDir(), `${active}.json`);
    const content = await readFile(palettePath, 'utf8');
    const palette: Palette = JSON.parse(content);

    // Derive some colors
    const bg = darken(palette.neutral || '#1f2937', 0.8);
    const fg = lighten(palette.neutral || '#e5e7eb', 0.2);

    const gitColor = palette.primary;
    const directoryColor = palette.secondary;
    const cmdSuccess = palette.success;
    const cmdError = palette.error;

    const starship = `# Generated by wellwell theme builder\n
add_newline = true
format = "$all"

[character]
success_symbol = "[❯](bold ${cmdSuccess})"
error_symbol = "[❯](bold ${cmdError})"

[directory]
style = "bold ${directoryColor}"
truncation_length = 3
truncate_to_repo = false

[git_branch]
style = "bold ${gitColor}"
format = "on [$symbol$branch]($style) "

[aws]
disabled = true

[nodejs]
disabled = true

[package]
disabled = true
`;

    // Build fzf config derived from palette (inspired by backup config)
    const border = darken(palette.neutral || '#262626', 0.2);
    const label = lighten(palette.neutral || '#aeaeae', 0.05);
    const query = lighten(palette.neutral || '#d9d9d9', 0.05);
    const highlight = palette.primary || '#0a7aca';
    const highlightPlus = lighten(highlight, 0.2);
    const info = '#afaf87';
    const marker = palette.success || '#4EC9B0';
    const prompt = palette.accent || palette.error || '#f44747';
    const spinner = palette.accent || '#DDB6F2';
    const pointer = spinner;
    const header = palette.secondary || '#87afaf';

    const fzf = `# Generated by wellwell theme builder\n\n# Load fzf key-bindings & completion from Homebrew if available\nif command -v brew >/dev/null 2>&1; then\n  __FZF_PREFIX="$(brew --prefix)/opt/fzf"\n  [ -f "$__FZF_PREFIX/shell/key-bindings.zsh" ] && source "$__FZF_PREFIX/shell/key-bindings.zsh"\n  [ -f "$__FZF_PREFIX/shell/completion.zsh" ] && source "$__FZF_PREFIX/shell/completion.zsh"\nfi\nunset __FZF_PREFIX\n\n# Preview\nexport FZF_PREVIEW_COMMAND='bat --style=numbers --color=always --line-range=:200 {} || eza --tree --level=2 --color=always {}'\nexport FZF_CTRL_T_OPTS='--preview "$FZF_PREVIEW_COMMAND"'\nexport FZF_CTRL_T_COMMAND='fd --type f --hidden --follow --exclude .git'\n\n# UI defaults\nexport FZF_DEFAULT_OPTS='\n  --border --height=80% --layout=reverse --info=inline-right\n  --color=fg:-1,fg+:#ffffff,bg:-1,bg+:#373737,hl:${highlight},hl+:${highlightPlus},info:${info},marker:${marker}\n  --color=prompt:${prompt},spinner:${spinner},pointer:${pointer},header:${header},border:${border},label:${label},query:${query},gutter:-1\n  --prompt="❯❯ " --marker=">" --pointer="*" --separator="" --scrollbar="│"'\n`;

    // Build Bat theme (.tmTheme) with richer structure inspired by Tomorrow-Night
    const tmBackground = darken(palette.neutral || '#1f2937', 0.85);
    const tmForeground = lighten(palette.neutral || '#e5e7eb', 0.2);
    const tmCaret = palette.accent || palette.primary || '#7c3aed';
    const tmSelection = lighten(tmBackground, 0.18);
    const tmLineHighlight = lighten(tmBackground, 0.08);
    const cComment = darken(palette.neutral || '#94a3b8', 0.2);
    const cString = palette.success || '#16a34a';
    const cNumber = palette.accent || '#f97316';
    const cKeyword = palette.primary || '#7c3aed';
    const cVariable = palette.secondary || '#06b6d4';
    const cFunction = palette.accent || palette.primary || '#7c3aed';
    const cType = palette.secondary || '#06b6d4';
    const cConstant = palette.accent || '#f97316';
    const cOperator = lighten(cKeyword, 0.2);
    const cPunctuation = lighten(palette.neutral || '#94a3b8', 0.15);

    const batTheme = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
  <key>name</key><string>wellwell</string>
  <key>settings</key>
  <array>
    <dict>
      <key>settings</key>
      <dict>
        <key>background</key><string>${tmBackground}</string>
        <key>foreground</key><string>${tmForeground}</string>
        <key>caret</key><string>${tmCaret}</string>
        <key>invisibles</key><string>${tmBackground}</string>
        <key>lineHighlight</key><string>${tmLineHighlight}</string>
        <key>selection</key><string>${tmSelection}</string>
      </dict>
    </dict>
    <dict>
      <key>name</key><string>Comment</string>
      <key>scope</key><string>comment</string>
      <key>settings</key><dict><key>foreground</key><string>${cComment}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>String</string>
      <key>scope</key><string>string</string>
      <key>settings</key><dict><key>foreground</key><string>${cString}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Number</string>
      <key>scope</key><string>constant.numeric</string>
      <key>settings</key><dict><key>foreground</key><string>${cNumber}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Keyword</string>
      <key>scope</key><string>keyword</string>
      <key>settings</key><dict><key>foreground</key><string>${cKeyword}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Variable</string>
      <key>scope</key><string>variable</string>
      <key>settings</key><dict><key>foreground</key><string>${cVariable}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Function name</string>
      <key>scope</key><string>entity.name.function</string>
      <key>settings</key><dict><key>foreground</key><string>${cFunction}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Type name</string>
      <key>scope</key><string>entity.name.type, support.type</string>
      <key>settings</key><dict><key>foreground</key><string>${cType}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Constant</string>
      <key>scope</key><string>constant, constant.language, support.constant</string>
      <key>settings</key><dict><key>foreground</key><string>${cConstant}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Operator</string>
      <key>scope</key><string>keyword.operator</string>
      <key>settings</key><dict><key>foreground</key><string>${cOperator}</string></dict>
    </dict>
    <dict>
      <key>name</key><string>Punctuation</string>
      <key>scope</key><string>punctuation</string>
      <key>settings</key><dict><key>foreground</key><string>${cPunctuation}</string></dict>
    </dict>
  </array>
  <key>uuid</key><string>wellwell-theme</string>
</dict>
</plist>`;

    await Promise.all([
      mkdir(STARSHIP_DOTFILES_ROOT, { recursive: true }),
      mkdir(FZF_DOTFILES_ROOT, { recursive: true }),
      mkdir(MANAGED_BAT_THEMES_DIR, { recursive: true }),
    ]);
    await writeFile(MANAGED_STARSHIP_TOML_PATH, starship, 'utf8');
    await writeFile(MANAGED_FZF_ZSH_PATH, fzf, 'utf8');
    const managedBatThemePath = path.join(MANAGED_BAT_THEMES_DIR, 'wellwell.tmTheme');
    await writeFile(managedBatThemePath, batTheme, 'utf8');
    // Opportunistically install to user bat themes and rebuild cache
    try {
      await mkdir(USER_BAT_THEMES_DIR, { recursive: true });
      const userBatThemePath = path.join(USER_BAT_THEMES_DIR, 'wellwell.tmTheme');
      await writeFile(userBatThemePath, batTheme, 'utf8');
      await runCommand('bat cache --build || true');
    } catch {}
    return { ok: true, message: `Theme built with palette "${palette.name || active}" and Starship/fzf/bat configs generated` };
  } catch (error) {
    return { ok: false, error: error as Error };
  }
}

export async function switchPalette(name: string): Promise<ActionResult> {
  try {
    const available = await listPalettes();
    if (!available.includes(name)) return { ok: false, message: `Palette not found: ${name}` };
    await setActivePaletteName(name);
    return await build();
  } catch (error) {
    return { ok: false, error: error as Error };
  }
}
