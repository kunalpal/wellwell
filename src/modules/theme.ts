import fs from 'node:fs';
import path from 'node:path';
import { promisify } from 'node:util';
import type { ActionResult, ItemStatus } from './types.js';
import { DOTFILES_ROOT, STARSHIP_DOTFILES_ROOT, MANAGED_STARSHIP_TOML_PATH } from '../lib/paths.js';

const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);
const mkdir = promisify(fs.mkdir);

export type Palette = { name?: string } & Record<string, string>;

function palettesDir() {
  return path.join(DOTFILES_ROOT, 'theme', 'palettes');
}

function activeFilePath() {
  return path.join(DOTFILES_ROOT, 'theme', 'active.json');
}

export async function listPalettes(): Promise<string[]> {
  const dir = palettesDir();
  try {
    const items = await fs.promises.readdir(dir);
    return items.filter((f) => f.endsWith('.json')).map((f) => f.replace(/\.json$/, ''));
  } catch {
    return [];
  }
}

export async function getActivePaletteName(): Promise<string | null> {
  try {
    const content = await readFile(activeFilePath(), 'utf8');
    const data = JSON.parse(content) as { name: string };
    return data.name || null;
  } catch {
    return null;
  }
}

export async function setActivePaletteName(name: string): Promise<void> {
  await fs.promises.mkdir(path.dirname(activeFilePath()), { recursive: true });
  await writeFile(activeFilePath(), JSON.stringify({ name }, null, 2), 'utf8');
}

function hexToRgb(hex: string) {
  const cleaned = hex.replace('#', '');
  const bigint = parseInt(cleaned, 16);
  return {
    r: (bigint >> 16) & 255,
    g: (bigint >> 8) & 255,
    b: bigint & 255,
  };
}

function lighten(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const adjust = (v: number) => Math.min(255, Math.round(v + 255 * amount));
  const toHex = (v: number) => v.toString(16).padStart(2, '0');
  return `#${toHex(adjust(r))}${toHex(adjust(g))}${toHex(adjust(b))}`;
}

function darken(hex: string, amount: number) {
  const { r, g, b } = hexToRgb(hex);
  const adjust = (v: number) => Math.max(0, Math.round(v - 255 * amount));
  const toHex = (v: number) => v.toString(16).padStart(2, '0');
  return `#${toHex(adjust(r))}${toHex(adjust(g))}${toHex(adjust(b))}`;
}

export async function getStatusList(): Promise<ItemStatus[]> {
  const available = await listPalettes();
  const active = (await getActivePaletteName()) || (available[0] ?? null);
  return [
    { id: 'theme-palettes', label: 'Palettes available', level: available.length > 0 ? 'ok' : 'error', details: available.join(', ') || 'None' },
    { id: 'theme-active', label: 'Active palette', level: active ? 'ok' : 'warning', details: active || 'None' },
    { id: 'starship-theme', label: 'Starship theme generated', level: fs.existsSync(MANAGED_STARSHIP_TOML_PATH) ? 'ok' : 'warning', details: MANAGED_STARSHIP_TOML_PATH },
  ];
}

export async function diff(): Promise<ActionResult> {
  return { ok: true, message: 'Theme diffs are generated artifacts; edit palette.json instead.' };
}

export async function install(): Promise<ActionResult> {
  return build();
}

export async function update(): Promise<ActionResult> {
  return build();
}

export async function build(): Promise<ActionResult> {
  try {
    const available = await listPalettes();
    let active = await getActivePaletteName();
    if (!active && available.length > 0) {
      active = available[0];
      await setActivePaletteName(active);
    }
    if (!active) return { ok: false, message: 'No palettes found' } as ActionResult;

    const palettePath = path.join(palettesDir(), `${active}.json`);
    const content = await readFile(palettePath, 'utf8');
    const palette: Palette = JSON.parse(content);

    // Derive some colors
    const bg = darken(palette.neutral || '#1f2937', 0.8);
    const fg = lighten(palette.neutral || '#e5e7eb', 0.2);

    const gitColor = palette.primary;
    const directoryColor = palette.secondary;
    const cmdSuccess = palette.success;
    const cmdError = palette.error;

    const starship = `# Generated by wellwell theme builder\n
add_newline = true
format = "$all"

[character]
success_symbol = "[❯](bold ${cmdSuccess})"
error_symbol = "[❯](bold ${cmdError})"

[directory]
style = "bold ${directoryColor}"
truncation_length = 3
truncate_to_repo = false

[git_branch]
style = "bold ${gitColor}"
format = "on [$symbol$branch]($style) "
`;

    await mkdir(STARSHIP_DOTFILES_ROOT, { recursive: true });
    await writeFile(MANAGED_STARSHIP_TOML_PATH, starship, 'utf8');
    return { ok: true, message: `Theme built with palette "${palette.name || active}" and Starship config generated` };
  } catch (error) {
    return { ok: false, error: error as Error };
  }
}

export async function switchPalette(name: string): Promise<ActionResult> {
  try {
    const available = await listPalettes();
    if (!available.includes(name)) return { ok: false, message: `Palette not found: ${name}` };
    await setActivePaletteName(name);
    return await build();
  } catch (error) {
    return { ok: false, error: error as Error };
  }
}
